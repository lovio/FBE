//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: variants_ptr.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "variants_ptr_ptr_pmr.h"

namespace variants_ptr_pmr {

auto is_equal(const Expr& lhs, const Expr& rhs) -> bool {
    if (lhs.index() != rhs.index())
        return false;
    switch (lhs.index()) {
        case 0: {
            return std::get<0>(lhs) == std::get<0>(rhs);
        }
        case 1: {
            return std::get<1>(lhs) == std::get<1>(rhs);
        }
        case 2: {
            return std::get<2>(lhs) == std::get<2>(rhs);
        }
        default: 
            return true;
    }
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Expr& value)
{
    stream << "Expr(variant|";
    [[maybe_unused]] bool first = true;
    switch (value.index()) {
        case 0:
            stream<< "{bool}";
            stream << std::get<0>(value);
            break;
        case 1:
            stream<< "{string}";
            stream << std::get<1>(value);
            break;
        case 2:
            stream<< "{int32}";
            stream << std::get<2>(value);
            break;
        default:
            static_assert("unreachable branch");
    }
    stream << ")";
    return stream;
}

auto is_equal(const V& lhs, const V& rhs) -> bool {
    if (lhs.index() != rhs.index())
        return false;
    switch (lhs.index()) {
        case 0: {
            return std::get<0>(lhs) == std::get<0>(rhs);
        }
        case 1: {
            return std::get<1>(lhs) == std::get<1>(rhs);
        }
        case 2: {
            return std::get<2>(lhs) == std::get<2>(rhs);
        }
        case 3: {
            return std::get<3>(lhs) == std::get<3>(rhs);
        }
        case 4: {
            return *std::get<4>(lhs) == *std::get<4>(rhs);
        }
        case 5: {
            auto& lhs_value = std::get<5>(lhs);
            auto& rhs_value = std::get<5>(rhs);
            if (lhs_value.size() != rhs_value.size())
                return false;
            for (size_t i = 0; i < lhs_value.size(); i++)
            {
                if (lhs_value[i] != rhs_value[i])
                    return false;
            }
            return true;
        }
        case 6: {
            auto& lhs_value = std::get<6>(lhs);
            auto& rhs_value = std::get<6>(rhs);
            if (lhs_value.size() != rhs_value.size())
                return false;
            for (size_t i = 0; i < lhs_value.size(); i++)
            {
                if (lhs_value[i] != rhs_value[i])
                    return false;
            }
            return true;
        }
        case 7: {
            auto& lhs_value = std::get<7>(lhs);
            auto& rhs_value = std::get<7>(rhs);
            if (lhs_value.size() != rhs_value.size())
                return false;
            for (auto & [k, v]: lhs_value)
            {
                auto pos = rhs_value.find(k);
                if (pos == rhs_value.end())
                    return false;
                if (pos->second != v)
                    return false;
            }
            return true;
        }
        case 8: {
            auto& lhs_value = std::get<8>(lhs);
            auto& rhs_value = std::get<8>(rhs);
            if (lhs_value.size() != rhs_value.size())
                return false;
            for (size_t i = 0; i < lhs_value.size(); i++)
            {
                if (lhs_value[i] != rhs_value[i])
                    return false;
            }
            return true;
        }
        case 9: {
            auto& lhs_value = std::get<9>(lhs);
            auto& rhs_value = std::get<9>(rhs);
            if (lhs_value.size() != rhs_value.size())
                return false;
            for (size_t i = 0; i < lhs_value.size(); i++)
            {
                if (lhs_value[i] != rhs_value[i])
                    return false;
            }
            return true;
        }
        case 10: {
            auto& lhs_value = std::get<10>(lhs);
            auto& rhs_value = std::get<10>(rhs);
            if (lhs_value.size() != rhs_value.size())
                return false;
            for (auto & [k, v]: lhs_value)
            {
                auto pos = rhs_value.find(k);
                if (pos == rhs_value.end())
                    return false;
                if (pos->second != v)
                    return false;
            }
            return true;
        }
        case 11: {
            auto& lhs_value = std::get<11>(lhs);
            auto& rhs_value = std::get<11>(rhs);
            if (lhs_value.size() != rhs_value.size())
                return false;
            for (auto & [k, v]: lhs_value)
            {
                auto pos = rhs_value.find(k);
                if (pos == rhs_value.end())
                    return false;
                if (pos->second != v)
                    return false;
            }
            return true;
        }
        case 12: {
            auto& lhs_value = std::get<12>(lhs);
            auto& rhs_value = std::get<12>(rhs);
            if (lhs_value.size() != rhs_value.size())
                return false;
            for (size_t i = 0; i < lhs_value.size(); i++)
            {
                if (*lhs_value[i] != *rhs_value[i])
                    return false;
            }
            return true;
        }
        case 13: {
            return is_equal(std::get<13>(lhs), std::get<13>(rhs));
        }
        default: 
            return true;
    }
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const V& value)
{
    stream << "V(variant|";
    [[maybe_unused]] bool first = true;
    switch (value.index()) {
        case 0:
            stream<< "{int32}";
            stream << std::get<0>(value);
            break;
        case 1:
            stream<< "{string}";
            stream << std::get<1>(value);
            break;
        case 2:
            stream<< "{double}";
            stream << std::get<2>(value);
            break;
        case 3:
            stream<< "{Simple}";
            stream << std::get<3>(value);
            break;
        case 4:
            stream<< "{Simple*}";
            stream << "ptr of other struct: " << (std::get<4>(value) == nullptr ? "nullptr" : "true");
            if (std::get<4>(value) != nullptr)
            {
                stream << "->" << *std::get<4>(value);
            }
            break;
        case 5:
            stream << "{Simple}=[" << std::get<5>(value).size() << "][";
            for (const auto& it : std::get<5>(value))
            {
                stream << std::string(first ? "" : ",") << it;
                first = false;
            }
            stream << "]";
            break;
        case 6:
            stream << "{int32}=[" << std::get<6>(value).size() << "][";
            for (const auto& it : std::get<6>(value))
            {
                stream << std::string(first ? "" : ",") << it;
                first = false;
            }
            stream << "]";
            break;
        case 7:
            stream << "{int32->Simple}=[" << std::get<7>(value).size() << "][";
            for (const auto& it : std::get<7>(value))
            {
                stream << std::string(first ? "" : ",") << it.first;
                stream << "->";
                stream << it.second;
                first = false;
            }
            stream << "]";
            break;
        case 8:
            stream << "{bytes}=[" << std::get<8>(value).size() << "][";
            for (const auto& it : std::get<8>(value))
            {
                stream << std::string(first ? "" : ",") << "bytes[" << it.size() << "]";
                first = false;
            }
            stream << "]";
            break;
        case 9:
            stream << "{string}=[" << std::get<9>(value).size() << "][";
            for (const auto& it : std::get<9>(value))
            {
                stream << std::string(first ? "" : ",") << "\"" << it << "\"";
                first = false;
            }
            stream << "]";
            break;
        case 10:
            stream << "{int32->bytes}=[" << std::get<10>(value).size() << "][";
            for (const auto& it : std::get<10>(value))
            {
                stream << std::string(first ? "" : ",") << it.first;
                stream << "->";
                stream << "bytes[" << it.second.size() << "]";
                first = false;
            }
            stream << "]";
            break;
        case 11:
            stream << "{string->bytes}=[" << std::get<11>(value).size() << "][";
            for (const auto& it : std::get<11>(value))
            {
                stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
                stream << "->";
                stream << "bytes[" << it.second.size() << "]";
                first = false;
            }
            stream << "]";
            break;
        case 12:
            stream << "{Simple*}=[" << std::get<12>(value).size() << "][";
            for (const auto& it : std::get<12>(value))
            {
                stream << std::string(first ? "" : ",") << "ptr of other struct: " << (it == nullptr ? "nullptr" : "true");
                if (it != nullptr)
                {
                    stream << "->" << *it;
                }
                first = false;
            }
            stream << "]";
            break;
        case 13:
            stream<< "{Expr}";
            stream << std::get<13>(value);
            break;
        default:
            static_assert("unreachable branch");
    }
    stream << ")";
    return stream;
}

} // namespace variants_ptr_pmr
